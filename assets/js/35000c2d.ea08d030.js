"use strict";(self.webpackChunk=self.webpackChunk||[]).push([[372],{4182:function(e,t,a){a.r(t),a.d(t,{frontMatter:function(){return i},contentTitle:function(){return l},metadata:function(){return c},toc:function(){return d},default:function(){return p}});var n=a(7462),r=a(3366),o=(a(7294),a(3905)),s=["components"],i={id:"caveats",title:"Caveats",sidebar_label:"Caveats"},l=void 0,c={unversionedId:"caveats",id:"caveats",isDocsHomePage:!1,title:"Caveats",description:"Proxy and state usage tracking may not work 100% as expected.",source:"@site/docs/caveats.md",sourceDirName:".",slug:"/caveats",permalink:"/docs/caveats",tags:[],version:"current",frontMatter:{id:"caveats",title:"Caveats",sidebar_label:"Caveats"},sidebar:"docs",previous:{title:"Debugging",permalink:"/docs/debugging"}},d=[{value:"Proxied states are referentially equal only in per-hook basis",id:"proxied-states-are-referentially-equal-only-in-per-hook-basis",children:[],level:2},{value:"An object referential change doesn&#39;t trigger re-render if an property of the object is accessed in previous render",id:"an-object-referential-change-doesnt-trigger-re-render-if-an-property-of-the-object-is-accessed-in-previous-render",children:[],level:2},{value:"Proxied state might behave unexpectedly outside render",id:"proxied-state-might-behave-unexpectedly-outside-render",children:[],level:2}],u={toc:d};function p(e){var t=e.components,a=(0,r.Z)(e,s);return(0,o.kt)("wrapper",(0,n.Z)({},u,a,{components:t,mdxType:"MDXLayout"}),(0,o.kt)("p",null,"Proxy and state usage tracking may not work 100% as expected.\nThere are some limitations and workarounds."),(0,o.kt)("h2",{id:"proxied-states-are-referentially-equal-only-in-per-hook-basis"},"Proxied states are referentially equal only in per-hook basis"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-javascript"},"const state1 = useTrackedState();\nconst state2 = useTrackedState();\n// state1 and state2 is not referentially equal\n// even if the underlying state is referentially equal.\n")),(0,o.kt)("p",null,"You should use ",(0,o.kt)("inlineCode",{parentName:"p"},"useTrackedState")," only once in a component\nif you need referential equality of objects in the state."),(0,o.kt)("h2",{id:"an-object-referential-change-doesnt-trigger-re-render-if-an-property-of-the-object-is-accessed-in-previous-render"},"An object referential change doesn't trigger re-render if an property of the object is accessed in previous render"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-javascript"},"const state = useTrackedState();\nconst { foo } = state;\nreturn <Child key={foo.id} foo={foo} />;\n\nconst Child = React.memo(({ foo }) => {\n  // ...\n};\n// if foo doesn't change, Child won't render, so foo.id is only marked as used.\n// it won't trigger Child to re-render even if foo is changed.\n")),(0,o.kt)("p",null,"You need to use a special ",(0,o.kt)("inlineCode",{parentName:"p"},"memo")," provided by this library."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-javascript"},"import { memo } from 'react-tracked';\n\nconst Child = memo(({ foo }) => {\n  // ...\n};\n")),(0,o.kt)("h2",{id:"proxied-state-might-behave-unexpectedly-outside-render"},"Proxied state might behave unexpectedly outside render"),(0,o.kt)("p",null,"Proxies are basically transparent, and it should behave like normal objects.\nHowever, there can be edge cases where it behaves unexpectedly.\nFor example, if you console.log a proxied value,\nit will display a proxy wrapping an object.\nNotice, it will be kept tracking outside render,\nso any prorerty access will mark as used to trigger re-render on updates."),(0,o.kt)("p",null,"useTrackedState will unwrap a Proxy before wrapping with a new Proxy,\nhence, it will work fine in usual use cases.\nThere's only one known pitfall: If you wrap proxied state with your own Proxy\noutside the control of useTrackedState,\nit might lead memory leaks, because useTrackedState\nwouldn't know how to unwrap your own Proxy."),(0,o.kt)("p",null,"To work around such edge cases, the first option is to use primitive values."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-javascript"},"const state = useTrackedState();\nconst dispatch = useUpdate();\ndispatch({ type: 'FOO', value: state.fooObj }); // Instead of using objects,\ndispatch({ type: 'FOO', value: state.fooStr }); // Use primitives.\n")),(0,o.kt)("p",null,"The second option is to use ",(0,o.kt)("inlineCode",{parentName:"p"},"getUntrackedObject"),"."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-javascript"},"import { getUntrackedObject } from 'react-tracked';\n\ndispatch({ type: 'FOO', value: getUntrackedObject(state.fooObj) });\n")),(0,o.kt)("p",null,"You could implement a special dispatch function to do this automatically.\nCheck out ",(0,o.kt)("a",{parentName:"p",href:"https://github.com/dai-shi/react-tracked/blob/main/examples/10_untracked/src/store.ts"},"examples/10_untracked/src/store.ts")," for a concrete example."))}p.isMDXComponent=!0}}]);